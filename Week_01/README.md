# 学习笔记

### 数组、链表和跳表

本周跟着覃超老师学习了数组、链表和跳表这三种常用的数据结构，并分析它们增、删、查操作相应的时间复杂度。

覃超老师以Java中的ArrayList和LinkedList为例，向我们展示了数组和链表在Java中的低层实现。

数组在Java中的对应实现是ArrayList，它查询时间复杂度为O(1),但增加、删除的复杂度为O(n)。添加时如果超出数组大小，ArrayList会申请原始空间2倍的空间，并将元素迁移过去。删除时，会涉及Arraycopy操作，将数组中的部分元素进行移动。正是这些操作使得ArrayList的在增加、删除操作上时间复杂度较低。

链表在Java中的对应实现是LinkedList，它实际上被实现为双向链表。LinkedList的增加和删除操作时间复杂度都为O(1)。但查询操作的时间复杂度为O(n)，即使链表中的元素有序，也不能加快其查询速度。因为二分查找不能应用与链表这种数据结构。

针对链表的这个缺陷，计算机科学家们提出了跳表（Skip List）这种数据结构。跳表中的元素必须是有序的，它对标的是平衡二叉树和二分查找。为了加快有序链表的的查询速度，我们需要对他进行升维，即给原始链表增加索引。一般第一层索引是对原始链表的每两个节点建立索引，因此其节点数是 n/2；第二层索引是每4个节点建立索引，因此其节点数是 n/4；以此类推，第 h 层索引是每 2^h 个节点建立索引，因此其节点数是 n/(2^h)。增加了索引节点后，跳表的查询时间复杂度从 O(n) 降为 O(logn)，但增加和删除的时间复杂也相应地从 O(1) 升到 O(logn)，因为需要额外的时间维护索引。至于空间复杂度，由于 n/2 + n/4 + … + 2 是收敛数列，所以其空间复杂度是 O(n)。跳表的具体实现比较复杂，一般不会在面试中要求实现，但其基本思想和时空复杂度需要牢记。

最后，覃超老师介绍了 LRU cache 的实现机制是 LinkedList，而 Redis 的实现机制是 Skip List。另外 Google 取代 BigTable 的 LevelDB 的低层实现也是 Skip List。 


### 如何有效刷题
课程中覃超老师以“移动 0”算法题为例，向我们介绍了应该“如何有效刷题”。覃超老师介绍的刷题方法包含四个步骤：

1.5-10分钟：读题和思考
2.有思路：自己开始做，然后写代码；没思路：马上看题解！
3.默写背诵、熟练
4.（第二遍）自己写

这里给我较大启迪的是“5-10分钟没有思路，马上看题解”，因为我们刷题是要准备面试，不是参加竞赛，更不是要我们从 0 到 1 自己创造新算法。因此快速熟悉常见问题及其相应的解法才是重点！

自己想方法的时候，一开始不要限制自己的想法，把能想到的任何解法都先记录一下，然后再进行对比。挑选较好的方法进行实现。自己提交的代码 ac 之后，也只是完成了这道题的 50%，接下来我们还需要去看题解，从题解中吸取营养：别人是如何实现的算法，实现的怎样，是否值得参考等等。看题解时：先看中文题解，再看英文题解；先看官方题解，再看其他优秀题解。

此外，覃超老师还告诫我们刷题最大的误区是：只刷一遍！一定要对刷过的题进行反复练习，覃超老师介绍的“五毒神掌”刷题法：

第一遍：
1.5-10分钟：读题和思考
2.有思路：自己开始做，然后写代码；没思路：马上看题解！学习多种解法，比较各种解法的优劣，重点是学习和理解各种算法，而不是字节造轮子
3.默写背诵、熟练优秀的解法，形成条件反射

第二遍：
1.马上自己写，然后 LeetCode 提交
2.尝试多种写法，进行优化

第三遍：
24小时后，再次重复做题，不同解法的熟练程度

第四遍：
一周后，反复练习相同的题目

第五遍：
面试前一周，恢复性做题

最后，算法要进行加速的核心思想有两个：第一是升维；第二是以空间换时间。