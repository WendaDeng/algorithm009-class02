# 学习笔记

## 本周学习的内容有数组、链表和跳表，栈、队列和优先级队列

### 数组、链表和跳表部分

本周跟着覃超老师学习了数组、链表和跳表这三种常用的数据结构，并分析它们增、删、查操作相应的时间复杂度。

覃超老师以Java中的ArrayList和LinkedList为例，向我们展示了数组和链表在Java中的低层实现。

数组在Java中的对应实现是ArrayList，它查询时间复杂度为O(1),但增加、删除的复杂度为O(n)。添加时如果超出数组大小，ArrayList会申请原始空间2倍的空间，并将元素迁移过去。删除时，会涉及Arraycopy操作，将数组中的部分元素进行移动。正是这些操作使得ArrayList的在增加、删除操作上时间复杂度较低。

链表在Java中的对应实现是LinkedList，它实际上被实现为双向链表。LinkedList的增加和删除操作时间复杂度都为O(1)。但查询操作的时间复杂度为O(n)，即使链表中的元素有序，也不能加快其查询速度。因为二分查找不能应用与链表这种数据结构。

针对链表的这个缺陷，计算机科学家们提出了跳表（Skip List）这种数据结构。跳表中的元素必须是有序的，它对标的是平衡二叉树和二分查找。为了加快有序链表的的查询速度，我们需要对他进行升维，即给原始链表增加索引。一般第一层索引是对原始链表的每两个节点建立索引，因此其节点数是 n/2；第二层索引是每4个节点建立索引，因此其节点数是 n/4；以此类推，第 h 层索引是每 2^h 个节点建立索引，因此其节点数是 n/(2^h)。增加了索引节点后，跳表的查询时间复杂度从 O(n) 降为 O(logn)，但增加和删除的时间复杂也相应地从 O(1) 升到 O(logn)，因为需要额外的时间维护索引。至于空间复杂度，由于 n/2 + n/4 + … + 2 是收敛数列，所以其空间复杂度是 O(n)。跳表的具体实现比较复杂，一般不会在面试中要求实现，但其基本思想和时空复杂度需要牢记。

最后，覃超老师介绍了 LRU cache 的实现机制是 LinkedList，而 Redis 的实现机制是 Skip List。另外 Google 取代 BigTable 的 LevelDB 的低层实现也是 Skip List。 
